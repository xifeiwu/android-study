android获取系统wifi状态等
WIFI
　　获取WIFI状态
　　　　WifiManager wifiManager = (WifiManager)context.getSystemService(Context.WIFI_SERVICE);
　　　　if(wifiManager != null){
　　　　　　int wifiState = wifiManager.getWifiState();
　　　　}
　　附：Wifi状态有以下几种：(括号内为所对应的的int值)
　　1. wifiManager.WIFI_STATE_DISABLED (1)
　　2. wifiManager..WIFI_STATE_ENABLED (3)
　　3. wifiManager..WIFI_STATE_DISABLING (0)
　　4 wifiManager..WIFI_STATE_ENABLING  (2)
 　　设置wifi状态
　　　　WifiManager wifiManager = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
　　　　if(wifiManager == null){
　　　　　　return;
　　　}
　　　　int wifiApState = wifiManager.getWifiApState();  //获取wifi AP状态
　　　　if((boolean值 && wifiApState == wifiManager.WIFI_AP_STATE_ENABLING || wifiApState == wifiManager.WIFI_AP_STATE_ENABLED){
　　　　　　wifiManager.setWifiApEnabled(null,false);
　　　}
　　　　wifiManager.setWifiEnabled(boolean值);

　　　　俩处boolean值应相同

Bluetooth
蓝牙有待后续补充

GPS
　　获取GPS状态
　　　　ContentResolver resolver = context.ContextResolver();
　　　　Boolean on = Settings.Secure.isLocationProviderEnabled(resolver, LocationManager.GPS_PROVIDER);
　　　　true为开启状态
　　设置GPS状态：
　　　　Settings..Secure.setLocationProviderEnabled(resolver,LocationManager.GPS_PROVIDER,boolean值);
　　　　true为开启状态

SYNC（同步）
 　获取当前系统同步状态
　　　　ContentResolver resolver = context.ContextResolver();
　　　　Boolean on = resolver.getMasterSyncAutomatically();
　　　　ConnectivityManager connManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
     设置同步
　　　　ContentResolver.setMasterSyncAutomatically(boolean值);


AirplaneMode（飞行模式）
　　获取系统当前飞行模式状态
　　　　ContentResolver resolver = context.ContextResolver();
　　　　boolean on = Settings.System.getInt(context.getContextResolver(),Settings.System.AIRPLANE_MODE_ON,0) == 1 ? true : false;
　　设置飞行模式：
　　　　Settings.System.putInt(context.getContentResolver(),Settings.System.AIRPLANE_MODE_ON,boolean值 ? 1 : 0);
　　　　Intent intent = new Intent(Intent.ACTION_AIRPLANE_MODE_CHANGED);
　　　　intent.putExtra("state",boolean值);
　　　　context.sendBroadcast(intent);
　　俩个boolean值应该一致；
 

自动旋转屏幕
　　获取系统当前自动旋屏设置
　　　　ContentResolver resolver = context.ContextResolver();
　　　　boolean on = Settings.System.getInt(context.getContResolver(),Settings.System.ACCELEROMETER_ROTATION) ==1 ? true : false;
　　设置自动旋屏
　　　　ContentResolver resolver = context.ContextResolver();
　　　　Uri uri = Settings.System.getUriFor("accelerometer_rotation");
　　　　Settings.System.putInt(resolver,"accelerometer_rotation",boolean值 ? 1 ：0);
　　　　resolver.notifyChange(uri,null);

静音模式
　　获取静音模式
　　public int getMuteMode(Context context){
　　　　AudioManager audioManager = (AudioManager)context.getSystmService(Context.AUDIO_SERVICE);
　　　　if(audioManager.getRingerMode == AudioManager.RINGER_MODE_SILENT){   //静音
　　　　　　return 0;
　　　　}else if(audioManager.getRingerMode == AudioManager.RINGER_MODE_VIBRATE){//振动
　　　　　　return 1;
　　　　} elsse {
　　　　　　retrn 2;
　　　　}
　　}

　　设置静音模式
　　public void setMute(Context context){
  　　　AudioManager audioManager = (AudioManager)context.getSystmService(Context.AUDIO_SERVICE);
　　　　switch(getMuteMode(context){
　　　　　　case 0:
　　　　　　　　audioManager.stRingerMode(AudioManager.RINGER_MODE_VIBRATE); //振动模式
　　　　　　　　break;
　　　　　　case 1:
　　　　　　　　audioManager.stRingerMode(AudioManager.RINGER_MODE_NORMAL); //正常模式
　　　　　　　　break;
　　　　　　case 2:
　　　　　　　　audioManager.stRingerMode(AudioManager.RINGER_MODE_SILENT); //静音模式
　　　　　　　　break;
　　　　　　default:
　　　　　　　　audioManager.stRingerMode(AudioManager.RINGER_MODE_NORMAL); //正常模式
　　　　}
　　}
 
 锁屏
　　PowerManager pm = (PowerManager)context.getSystemService(context.POWER_SERVICE);
　　pm.goToSleep(SystemClock.uptimeMillis());



List 接口对Collection进行了简单的扩充，它的具体实现类常用的有ArrayList和LinkedList。你可以将任何东西放到一个List容器 中，并在需要时从中取出。ArrayList从其命名中可以看出它是一种类似数组的形式进行存储，因此它的随机访问速度极快，而LinkedList的内 部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作。在具体应用时可以根据需要自由选择。前面说的Iterator只能对容器进行向前遍历，而 ListIterator则继承了Iterator的思想，并提供了对List进行双向遍历的方法。
Set接口也是 Collection的一种扩展，而与List不同的时，在Set中的对象元素不能重复，也就是说你不能把同样的东西两次放入同一个Set容器中。它的常 用具体实现有HashSet和TreeSet类。HashSet能快速定位一个元素，但是你放到HashSet中的对象需要实现hashCode()方 法，它使用了前面说过的哈希码的算法。而TreeSet则将放入其中的元素按序存放，这就要求你放入其中的对象是可排序的，这就用到了集合框架提供的另外 两个实用类Comparable和Comparator。一个类是可排序的，它就应该实现Comparable接口。有时多个类具有相同的排序算法，那就 不需要在每分别重复定义相同的排序算法，只要实现Comparator接口即可。集合框架中还有两个很实用的公用类：Collections和Arrays。Collections提供了对一个Collection容器进行诸如排序、复制、查找和填充等一些非常有用的方法，Arrays则是对一 个数组进行类似的操作。
Map是一种把键对象和值对象进行关联的容器，而一个值对象又可以是一个Map，依次类推，这样就可 形成一个多级映射。对于键对象来说，像Set一样，一个Map容器中的键对象不允许重复，这是为了保持查找结果的一致性;如果有两个键对象一样，那你想得 到那个键对象所对应的值对象时就有问题了，可能你得到的并不是你想的那个值对象，结果会造成混乱，所以键的唯一性很重要，也是符合集合的性质的。当然在使 用过程中，某个键所对应的值对象可能会发生变化，这时会按照最后一次修改的值对象与键对应。对于值对象则没有唯一性的要求。你可以将任意多个键都映射到一 个值对象上，这不会发生任何问题（不过对你的使用却可能会造成不便，你不知道你得到的到底是那一个键所对应的值对象）。Map有两种比较常用的实现： HashMap和TreeMap。HashMap也用到了哈希码的算法，以便快速查找一个键，TreeMap则是对键按序存放，因此它便有一些扩展的方 法，比如firstKey(),lastKey()等，你还可以从TreeMap中指定一个范围以取得其子Map。键和值的关联很简单，用pub (Object key,Object value)方法即可将一个键与一个值对象相关联。用get(Object key)可得到与此key对象所对应的值对象。
